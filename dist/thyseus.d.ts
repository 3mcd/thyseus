// Generated by dts-bundle-generator v6.13.0

interface SendableInstance<T extends SendableType = SendableType> {
	[ThreadProtocol.Send](): T;
}
interface SendableClass<T extends SendableType = void> {
	new (...args: any[]): SendableInstance<T>;
	[ThreadProtocol.Receive](data: T): SendableInstance<T>;
}
declare type SendableType = void | null | undefined | boolean | number | string | bigint | Date | RegExp | Blob | File | FileList | ArrayBuffer | SharedArrayBuffer | Uint8Array | Uint16Array | Uint32Array | BigUint64Array | Int8Array | Int16Array | Int32Array | BigInt64Array | Float32Array | Float32Array | Uint8ClampedArray | DataView | ImageBitmap | ImageData | SendableType[] | {
	[key: string]: SendableType;
} | Map<SendableType, SendableType> | Set<SendableType> | SendableInstance;
interface WorkerOrGlobal {
	postMessage(content: any): void;
	addEventListener(type: "message", fn: Function): void;
	removeEventListener(type: "message", fn: Function): void;
}
declare const Send: unique symbol;
declare const Receive: unique symbol;
export declare const ThreadProtocol: {
	readonly Send: typeof Send;
	readonly Receive: typeof Receive;
};
declare class Thread {
	#private;
	static Context: {
		Main: boolean;
		Worker: boolean;
	};
	static spawn(count: number, url: string | URL | undefined, sendableTypes: SendableClass[]): Thread[];
	static execute(context: boolean, fn: () => void): void;
	static createOrReceive<T extends SendableType>(context: boolean, threads: Thread[], create: () => T): Promise<T>;
	constructor(handler: WorkerOrGlobal, sendableTypes: SendableClass[]);
	send(message: SendableType): this;
	receive<T extends any = unknown>(timeout?: number): Promise<T>;
}
export declare enum Type {
	u8 = 0,
	u16 = 1,
	u32 = 2,
	u64 = 3,
	i8 = 4,
	i16 = 5,
	i32 = 6,
	i64 = 7,
	f32 = 8,
	f64 = 9
}
declare const typeToConstructor: {
	0: Uint8ArrayConstructor;
	1: Uint16ArrayConstructor;
	2: Uint32ArrayConstructor;
	3: BigUint64ArrayConstructor;
	4: Int8ArrayConstructor;
	5: Int16ArrayConstructor;
	6: Int32ArrayConstructor;
	7: BigInt64ArrayConstructor;
	8: Float32ArrayConstructor;
	9: Float64ArrayConstructor;
};
declare type TypeToTypedArray<T extends Type> = typeof typeToConstructor[T];
declare type SchemaField = Type | ComponentType<any>;
declare type Schema = SchemaField[] | {
	[key: string]: SchemaField;
};
declare type ComponentStore<T extends Schema = Schema> = {
	[Key in keyof T]: T[Key] extends Type ? TypeToTypedArray<T[Key]> : T extends ComponentType<infer X> ? ComponentStore<X> : ComponentStore<T[Key] extends Schema ? T[Key] : never>;
};
declare type SchemaInstance<T extends Schema> = {
	[Key in keyof T]: T[Key] extends Type.u64 | Type.i64 ? bigint : number;
};
interface ComponentType<T extends Schema = {}, I extends object = SchemaInstance<T>> {
	schema: T;
	new (store: ComponentStore<T>, index: number): I;
}
export function Component(schema?: null | undefined): ComponentType<{}>;
export function Component<T extends Schema>(schema: T): ComponentType<T>;
interface WorldConfig {
	threads: number;
	maxEntities: number;
}
interface SingleThreadedWorldConfig extends WorldConfig {
	threads: 1;
}
interface Class {
	new (...args: any[]): object;
}
interface System {
	args: any[];
	execute(...args: any[]): void;
}
declare type ResourceType = SendableClass<SendableType> | Class;
declare class BigUintArray {
	#private;
	static with(width: number, length: number, isShared?: boolean): BigUintArray;
	width: number;
	length: number;
	constructor(width: number, length: number, data: Uint8Array);
	get bytesPerElement(): number;
	get byteLength(): number;
	get(element: number): bigint;
	set(element: number, value: bigint): void;
	OR(element: number, value: bigint): void;
	AND(element: number, value: bigint): void;
	XOR(element: number, value: bigint): void;
	[ThreadProtocol.Send](): SerializedBigUintNArray;
	static [ThreadProtocol.Receive]([width, length, data,]: SerializedBigUintNArray): BigUintArray;
}
declare type SerializedBigUintNArray = [
	width: number,
	length: number,
	data: Uint8Array
];
declare class IndexAllocator {
	#private;
	static with(maxCount: number, isShared: boolean): IndexAllocator;
	constructor(data: Uint32Array, free: Uint32Array);
	get(): number;
	free(index: number): void;
	[ThreadProtocol.Send](): SerializedIA;
	static [ThreadProtocol.Receive]([data, free]: SerializedIA): IndexAllocator;
}
declare type SerializedIA = [
	Uint32Array,
	Uint32Array
];
declare class SparseSet {
	#private;
	static with(length: number, isShared?: boolean): SparseSet;
	sparse: Uint32Array;
	dense: Uint32Array;
	constructor(sparse: Uint32Array, dense: Uint32Array, metadata: Uint32Array);
	get size(): number;
	set size(value: number);
	has(value: number): boolean;
	add(value: number): this;
	delete(value: number): boolean;
	clear(): void;
	[Symbol.iterator](): Generator<number, void, unknown>;
	[ThreadProtocol.Send](): SerializedSparseSet;
	static [ThreadProtocol.Receive]([sparse, dense, meta,]: SerializedSparseSet): SparseSet;
}
declare type SerializedSparseSet = [
	sparse: Uint32Array,
	dense: Uint32Array,
	meta: Uint32Array
];
declare class WorldCommands {
	#private;
	static fromWorld(config: WorldConfig, componentCount: number): WorldCommands;
	entityData: BigUintArray;
	modifiedEntities: SparseSet;
	constructor(allocator: IndexAllocator, entityData: BigUintArray, modifiedEntities: SparseSet);
	private __$$setComponents;
	/**
	 * Queues an entity to be spawned.
	 * @returns `EntityCommands` to add/remove components from an entity.
	 */
	spawn(): EntityCommands;
	/**
	 * Queues an entity to be despawned.
	 * @param uuid The UUID (Entity & Generation ID) of the entity to despawn.
	 * @returns `this`
	 */
	despawn(id: number): this;
	/**
	 * Gets an entity to modify.
	 * @param id The id of the entity to get.
	 * @returns `EntityCommands` to add/remove components from an entity.
	 */
	get(id: number): EntityCommands;
	[ThreadProtocol.Send](): SerializedWorldCommands;
	static [ThreadProtocol.Receive]([alloc, entityData, modified,]: SerializedWorldCommands): WorldCommands;
}
declare type SerializedWorldCommands = [
	IndexAllocator,
	BigUintArray,
	SparseSet
];
declare class EntityCommands {
	#private;
	private __$$setId;
	private __$$setComponents;
	constructor(worldCommands: WorldCommands, entityData: BigUintArray, modifiedEntities: SparseSet);
	initialize(Component: ComponentType<any, any>): this;
	insert(Component: ComponentType<any, any>): this;
	remove(Component: ComponentType): this;
	despawn(): void;
}
declare type DescriptorToArgument<T extends Descriptor> = ReturnType<T["intoArgument"]>;
interface Descriptor {
	isLocalToThread(): boolean;
	intersectsWith(other: unknown): boolean;
	onAddSystem(worldBuilder: WorldBuilder): void;
	intoArgument(world: World): any;
}
declare class CommandsDescriptor implements Descriptor {
	isLocalToThread(): boolean;
	intersectsWith(other: unknown): boolean;
	intoArgument(world: World): WorldCommands;
	onAddSystem(builder: WorldBuilder): void;
}
declare enum AccessType {
	Read = 0,
	Write = 1
}
interface Mutable<T extends Class> {
	0: T;
	1: 1;
}
export declare function Mut<T extends Class>(x: T): Mutable<T>;
export declare namespace Mut {
	var isMut: <T extends Class = Class>(x: unknown) => x is Mutable<T>;
}
interface Query<C extends object> {
	[Symbol.iterator](): Iterator<C>;
}
declare type QueryMember = ComponentType<any, any> | Mutable<ComponentType<any, any>>;
declare class QueryDescriptor<C extends QueryMember[]> implements Descriptor {
	components: ComponentType<any, any>[];
	accessType: AccessType[];
	constructor(components: [
		...C
	]);
	isLocalToThread(): boolean;
	intersectsWith(other: unknown): boolean;
	onAddSystem(builder: WorldBuilder): void;
	intoArgument(world: World): Query<{
		[Index in keyof C]: C[Index] extends Mutable<infer X> ? InstanceType<X> : Readonly<InstanceType<C[Index] extends ComponentType<any, any> ? C[Index] : never>>;
	}>;
}
declare class ResourceDescriptor<T extends ResourceType | Mutable<ResourceType>> implements Descriptor {
	resource: ResourceType;
	accessType: AccessType;
	constructor(resource: T);
	isLocalToThread(): boolean;
	intersectsWith(other: unknown): boolean;
	onAddSystem(builder: WorldBuilder): void;
	intoArgument(world: World): T extends Mutable<infer X> ? InstanceType<X> : Readonly<InstanceType<T extends Class ? T : never>>;
}
declare class WorldDescriptor implements Descriptor {
	isLocalToThread(): boolean;
	intersectsWith(other: unknown): boolean;
	intoArgument(world: World): World;
	onAddSystem(builder: WorldBuilder): void;
}
export declare const P: {
	Commands: () => CommandsDescriptor;
	Query: <C extends (ComponentType<any, any> | Mutable<ComponentType<any, any>>)[]>(components: [
		...C
	]) => QueryDescriptor<C>;
	Res: <T extends ResourceType | Mutable<ResourceType>>(resource: T) => ResourceDescriptor<T>;
	World: () => WorldDescriptor;
};
declare type Parameters<T extends Descriptor[]> = {
	[Index in keyof T]: DescriptorToArgument<T[Index]>;
};
interface SystemDefinition<T extends Descriptor[] = Descriptor[]> {
	fn(...args: Parameters<T>): void;
	parameters: T;
}
export function defineSystem<T extends Descriptor[]>(parameters: [
	...T
], fn: (...args: Parameters<T>) => void): SystemDefinition<T>;
interface Dependencies {
	before?: SystemDefinition[];
	after?: SystemDefinition[];
	beforeAll?: boolean;
	afterAll?: boolean;
}
declare const _default: SystemDefinition<[
	default
]>;
declare type Plugin = (worldBuilder: WorldBuilder) => void;
export function definePlugin<T extends Plugin>(plugin: T): T;
declare class WorldBuilder {
	#private;
	constructor(config: WorldConfig, url: string | URL | undefined);
	get resources(): Set<ResourceType>;
	get queries(): Set<QueryDescriptor<any>>;
	get components(): Set<ComponentType<{}, SchemaInstance<{}>>>;
	get config(): WorldConfig;
	get url(): string | URL | undefined;
	/**
	 * Adds a system to the world and processes its parameter descriptors.
	 * @param system The system to add.
	 * @param dependencies The dependencies of this system.
	 * @returns `this`, for chaining.
	 */
	addSystem(system: SystemDefinition, dependencies?: Dependencies): this;
	/**
	 * Adds a system to the world _**that will only be run once when built**_.
	 * @param system The system to add.
	 * @returns `this`, for chaining.
	 */
	addStartupSystem(system: SystemDefinition): this;
	/**
	 * Passes this WorldBuilder to the provided plugin function.
	 * @returns `this`, for chaining.
	 */
	addPlugin(plugin: Plugin): this;
	/**
	 * Registers a Component in the world. Called automatically for all queried components when a system is added.
	 * @param Component The ComponentType to register.
	 * @returns `this`, for chaining.
	 */
	registerComponent(ComponentType: ComponentType<any>): this;
	/**
	 * Registers a Resource in the world. Called automatically for all accessed resources when a system is added.
	 * @param Component The ResourceType to register.
	 * @returns `this`, for chaining.
	 */
	registerResource(ResourceType: ResourceType): this;
	/**
	 * Registers a Resource in the world. Called automatically for all used sendable classes when a system is added.
	 * @param Component The SendableClass to register.
	 * @returns `this`, for chaining.
	 */
	registerSendableClass(SendableClass: SendableClass<any>): this;
	/**
	 * Registers a query in the world. Called automatically for all query parameters.
	 * @param descriptor The query descriptor to register.
	 * @returns `this`, for chaining.
	 */
	registerQuery(descriptor: QueryDescriptor<any>): this;
	/**
	 * Builds the world.
	 * `World` instances cannot add new systems or register new types.
	 * This method returns a promise for both single- _and_ multi-threaded worlds.
	 * @returns `Promise<World>`
	 */
	build(): Promise<World>;
}
declare class Mutex<T extends any> {
	#private;
	constructor(data: T, state?: Int32Array);
	get isLocked(): boolean;
	UNSAFE_getData(): T;
	request<R extends (data: T) => any>(fn: R): Promise<ReturnType<R>>;
	[ThreadProtocol.Send](): [
		T,
		Int32Array
	];
	static [ThreadProtocol.Receive]<T>([data, state]: [
		T,
		Int32Array
	]): Mutex<T>;
}
declare class Executor {
	#private;
	static from(intersections: bigint[], dependencies: bigint[], local: Set<number>): Executor;
	constructor(intersections: bigint[], dependencies: bigint[], systemsToExecute: SparseSet, lock: Mutex<BigUintArray>, local: Set<number>);
	add(system: number): void;
	start(): void;
	reset(): void;
	onReady(fn: () => void): Promise<void>;
	[Symbol.asyncIterator](): AsyncGenerator<number, void, unknown>;
	[ThreadProtocol.Send](): SerializedExecutor;
	static [ThreadProtocol.Receive](data: SerializedExecutor): Executor;
}
declare type SerializedExecutor = [
	intersections: bigint[],
	dependencies: bigint[],
	systemsToExecute: SparseSet,
	lock: Mutex<BigUintArray>
];
declare class World {
	#private;
	static new(config?: Partial<SingleThreadedWorldConfig>): WorldBuilder;
	static new(config: Partial<WorldConfig>, url: string | URL): WorldBuilder;
	constructor(components: Map<ComponentType, ComponentStore>, resources: Map<ResourceType, object>, queries: Map<QueryDescriptor<any>, Query<any>>, threads: Thread[], systems: System[], executor: Executor, commands: WorldCommands);
	get threads(): Thread[];
	get resources(): Map<ResourceType, object>;
	get queries(): Map<QueryDescriptor<any>, Query<any>>;
	get components(): Map<ComponentType<{}, SchemaInstance<{}>>, ComponentStore<Schema>>;
	get commands(): WorldCommands;
	update(): Promise<void>;
}

export {
	World as default,
	_default as applyCommands,
};

export {};
