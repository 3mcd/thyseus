// Generated by dts-bundle-generator v6.12.0

declare enum SystemRelationship {
	Disjoint = 0,
	Intersecting = 1
}
interface Class<I extends object = {}, P extends any[] = [
]> {
	new (...args: P): I;
}
interface System {
	args: any[];
	execute(...args: any[]): void;
}
export declare enum Type {
	u8 = 0,
	u16 = 1,
	u32 = 2,
	u64 = 3,
	i8 = 4,
	i16 = 5,
	i32 = 6,
	i64 = 7,
	f32 = 8,
	f64 = 9
}
declare const typeToConstructor: {
	0: Uint8ArrayConstructor;
	1: Uint16ArrayConstructor;
	2: Uint32ArrayConstructor;
	3: BigUint64ArrayConstructor;
	4: Int8ArrayConstructor;
	5: Int16ArrayConstructor;
	6: Int32ArrayConstructor;
	7: BigInt64ArrayConstructor;
	8: Float32ArrayConstructor;
	9: Float64ArrayConstructor;
};
declare type TypeToTypedArray<T extends Type> = typeof typeToConstructor[T];
declare type SchemaField = Type | SchemaClass<any>;
declare type Schema = SchemaField[] | {
	[key: string]: SchemaField;
};
declare type SchemaInstance<T extends Schema> = {
	[Key in keyof T]: T[Key] extends Type.u64 | Type.i64 ? bigint : number;
};
declare type SchemaData<T extends Schema = Schema> = {
	[Key in keyof T]: T[Key] extends Type ? TypeToTypedArray<T[Key]> : T extends SchemaClass<infer X> ? SchemaData<X> : SchemaData<T[Key] extends Schema ? T[Key] : never>;
};
interface SchemaClass<T extends Schema = {}, I extends object = SchemaInstance<T>> extends Class<I, [
	store: SchemaData<T>,
	index: number
]> {
	schema: T;
}
export declare function Component(schema?: null | undefined): SchemaClass<{}>;
export declare function Component<T extends Schema>(schema: T): SchemaClass<T>;
export declare namespace Component {
	var is: typeof isSchemaClass;
}
declare function isSchemaClass(val: unknown): val is SchemaClass;
declare const IsSentByThread = "@IS_SENT_BY_THREAD";
interface SendableInstance<T extends SendableType = SendableType> {
	[Thread.Send](): T;
}
interface SendableClass<T extends SendableType = undefined> extends Class<SendableInstance<T>, any[]> {
	[Thread.Receive](data: T): SendableInstance<T>;
}
interface SentInstance {
	[IsSentByThread]: [
		number,
		SendableType
	];
}
declare type SendableType = null | undefined | boolean | number | string | bigint | Date | RegExp | Blob | File | FileList | ArrayBuffer | SharedArrayBuffer | Uint8Array | Uint16Array | Uint32Array | BigUint64Array | Int8Array | Int16Array | Int32Array | BigInt64Array | Float32Array | Float32Array | Uint8ClampedArray | DataView | ImageBitmap | ImageData | object | SendableType[] | {
	[key: string]: SendableType;
} | Map<SendableType, SendableType> | Set<SendableType> | SentInstance;
export declare class Thread extends Worker {
	#private;
	static readonly Send: unique symbol;
	static readonly Receive: unique symbol;
	static globalSendableTypes: SendableClass[];
	static send(message: SendableType): typeof Thread;
	static receive<T extends any = unknown>(timeout?: number): Promise<T>;
	static isSendableClass<T extends SendableType = undefined>(x: unknown): x is SendableClass<T>;
	constructor(scriptURL: string | URL, sendableTypes: SendableClass[]);
	send(message: SendableType): this;
	receive<T extends any = unknown>(timeout?: number): Promise<T>;
}
declare class SparseSet {
	#private;
	dense: Uint32Array;
	sparse: Uint32Array;
	static with(length: number, isShared?: boolean): SparseSet;
	constructor(sparse: Uint32Array, dense: Uint32Array, metadata: Uint32Array);
	get size(): number;
	set size(value: number);
	has(value: number): boolean;
	add(value: number): this;
	delete(value: number): boolean;
	clear(): void;
	[Symbol.iterator](): Generator<number, void, unknown>;
	[Thread.Send](): SerializedSparseSet;
	static [Thread.Receive]([sparse, dense, meta,]: SerializedSparseSet): SparseSet;
}
declare type SerializedSparseSet = [
	sparse: Uint32Array,
	dense: Uint32Array,
	meta: Uint32Array
];
interface Query<C extends object> {
	[Symbol.iterator](): Iterator<C>;
}
declare class TupleQuery<C extends object[]> implements Query<C> {
	#private;
	entities: SparseSet;
	constructor(components: SchemaClass[], stores: SchemaData[], entities: SparseSet, filter: bigint);
	[Symbol.iterator](): Iterator<C>;
	testAdd(i: number, n: bigint): void;
}
declare class EntityManager {
	#private;
	constructor(stores: SchemaData[], components: SchemaClass[], queries: Query<any>[]);
	private updateQueries;
	spawn(...components: SchemaClass<any, any>[]): number;
	despawn(entity: number): void;
	insert(entity: number, ...components: SchemaClass<any, any>[]): void;
	remove(entity: number, ...components: SchemaClass[]): void;
}
interface WorldConfig {
	threads: number;
	maxEntities: number;
}
interface SingleThreadedWorldConfig extends WorldConfig {
	threads: 1;
}
declare type DescriptorToArgument<T extends Descriptor> = T["__T"];
interface Descriptor {
	type: unknown;
	data: unknown;
	__T: unknown;
}
interface Parameter<T extends Descriptor = Descriptor> {
	get type(): symbol;
	isLocalToThread(descriptor: T): boolean;
	getRelationship(left: T, right: T): SystemRelationship;
	extendSendable?(): SendableClass[];
	onAddSystem?(descriptor: T): void;
	onBuildMainWorld?(parameters: Parameter[]): void;
	onBuildThreadWorld?(...args: unknown[]): unknown;
	onBuildSystem(descriptor: T): DescriptorToArgument<T>;
	sendToThread?(): SendableType;
	receiveOnThread?(data: SendableType): void;
}
declare const ENTITIES_TYPE: unique symbol;
declare class EntitiesParameter implements Parameter<EntitiesDescriptor> {
	#private;
	get type(): symbol;
	entityManager: EntityManager | null;
	constructor(config: WorldConfig);
	onBuildMainWorld(parameters: Parameter[]): void;
	onBuildSystem(): EntityManager;
	isLocalToThread(): boolean;
	getRelationship(left: EntitiesDescriptor, right: EntitiesDescriptor): SystemRelationship;
	static createDescriptor(): EntitiesDescriptor;
}
interface EntitiesDescriptor {
	type: typeof ENTITIES_TYPE;
	data: null;
	__T: EntityManager;
}
interface Mutable<T extends Class | SchemaClass<any, any>> {
	0: T;
	1: 1;
}
export declare function Mut<T extends Class | SchemaClass<any, any>>(x: T): Mutable<T>;
export declare namespace Mut {
	var is: typeof isMut;
}
declare function isMut<T extends Class | SchemaClass = Class | SchemaClass>(x: unknown): x is Mutable<T>;
declare enum AccessType {
	Read = 0,
	Write = 1
}
declare const QUERY_TYPE: unique symbol;
declare class QueryParameter implements Parameter<QueryDescriptor<any>> {
	#private;
	get type(): symbol;
	queries: TupleQuery<any>[];
	components: SchemaClass[];
	stores: SchemaData[];
	constructor(config: WorldConfig);
	onAddSystem({ data }: QueryDescriptor<[
	]>): void;
	onBuildMainWorld(): void;
	onBuildSystem({ data }: QueryDescriptor<[
	]>): TupleQuery<object[]>;
	sendToThread(): (SchemaData<Schema>[] | SparseSet[])[];
	receiveOnThread([sparseSets, stores]: [
		SparseSet[],
		SchemaData[]
	]): void;
	isLocalToThread(): boolean;
	getRelationship(left: QueryDescriptor<[
	]>, right: QueryDescriptor<[
	]>): SystemRelationship;
	static createDescriptor<C extends QueryMember[]>(components: [
		...C
	]): QueryDescriptor<C>;
}
declare type QueryMember = SchemaClass<any, any> | Mutable<SchemaClass<any, any>>;
interface QueryDescriptor<T extends QueryMember[]> {
	type: typeof QUERY_TYPE;
	data: {
		components: SchemaClass<any, any>[];
		accessType: AccessType[];
	};
	__T: Query<{
		[Key in keyof T]: T[Key] extends SchemaClass<any, any> ? Readonly<InstanceType<T[Key]>> : T[Key] extends Mutable<infer X> ? X extends SchemaClass<any, any> ? InstanceType<X> : never : never;
	}>;
}
declare const RESOURCE_TYPE: unique symbol;
declare class ResourceParameter implements Parameter<ResourceDescriptor> {
	#private;
	get type(): symbol;
	constructor(config: WorldConfig);
	onBuildMainWorld(): void;
	onAddSystem({ data: { resource } }: ResourceDescriptor): void;
	extendSendable(): SendableClass<undefined>[];
	sendToThread(): object[][];
	receiveOnThread([stores, instances]: [
		object[],
		SendableInstance[]
	]): void;
	onBuildSystem({ data: { resource } }: ResourceDescriptor): object;
	isLocalToThread({ data: { resource } }: ResourceDescriptor): boolean;
	getRelationship(left: ResourceDescriptor, right: ResourceDescriptor): SystemRelationship;
	static createDescriptor<T extends AnyResource>(resource: T): ResourceDescriptor<T>;
}
declare type AnyResource = Class<object, [
]> | SchemaClass<any, any> | SendableClass | Mutable<Class | SchemaClass | SendableClass>;
interface ResourceDescriptor<T extends AnyResource = AnyResource> {
	type: typeof RESOURCE_TYPE;
	data: {
		resource: Class<object, any[]>;
		accessType: AccessType;
	};
	__T: T extends Mutable<infer X> ? InstanceType<X> : T extends Class<infer X> ? Readonly<X> : T extends SchemaClass<any, any> ? Readonly<InstanceType<T>> : never;
}
export declare const P: {
	Entities: typeof EntitiesParameter.createDescriptor;
	Query: typeof QueryParameter.createDescriptor;
	Res: typeof ResourceParameter.createDescriptor;
};
declare type Parameters<T extends Descriptor[]> = {
	[Index in keyof T]: DescriptorToArgument<T[Index]>;
};
interface SystemDefinition<T extends Descriptor[] = any> {
	fn(...args: Parameters<T>): void;
	parameters: T;
}
export function defineSystem<T extends Descriptor[]>(parameters: [
	...T
], fn: (...args: Parameters<T>) => void): SystemDefinition<T>;
interface Dependencies {
	before?: SystemDefinition[];
	after?: SystemDefinition[];
	beforeAll?: boolean;
	afterAll?: boolean;
}
declare class WorldBuilder {
	#private;
	constructor(config: WorldConfig, url: string | URL | undefined);
	addSystem(system: SystemDefinition, dependencies?: Dependencies): this;
	addStartupSystem(system: SystemDefinition): this;
	build(): Promise<World>;
}
interface Executor {
	add(sid: number): void;
	start(): void;
	iter(local: Set<number>): AsyncGenerator<number, void, unknown>;
	onReady(callback: () => void): Promise<void>;
	reset(): void;
}
declare class World {
	#private;
	static new(config?: Partial<SingleThreadedWorldConfig>): WorldBuilder;
	static new(config: Partial<WorldConfig>, url: string | URL): WorldBuilder;
	constructor(systems: System[], entityManager: EntityManager, threads: Thread[], executor: Executor, localSystems: Set<number>);
	update(): Promise<void>;
}

export {
	World as default,
};

export {};
