(function(g,q){typeof exports=="object"&&typeof module<"u"?q(exports,require("esm-env")):typeof define=="function"&&define.amd?define(["exports","esm-env"],q):(g=typeof globalThis<"u"?globalThis:g||self,q(g.Thyseus={},g.esm_env))})(this,function(g,q){"use strict";function w(n,t,e=Error){if(q.DEV&&!n)throw new e(t)}function x(n){return n+7&-8}const E={};let d,W,f,ft=0;const _=8,S=4,A=4,N=8,dt=16;function X(){for(;Atomics.compareExchange(f,_>>2,0,1)===1;);}function $(){Atomics.store(f,_>>2,0)}function Bt(n,t=!1){if(d)return d;if(typeof n=="number"){const e=t?SharedArrayBuffer:ArrayBuffer;d=new e(x(n))}else d=n;return W=new Uint8Array(d),f=new Uint32Array(d),E.buffer=d,E.u8=W,E.u16=new Uint16Array(d),E.u32=f,E.u64=new BigUint64Array(d),E.i8=new Int8Array(d),E.i16=new Int16Array(d),E.i32=new Int32Array(d),E.i64=new BigInt64Array(d),E.f32=new Float32Array(d),E.f64=new Float64Array(d),E.dataview=new DataView(d),ft=d.byteLength-4,typeof n=="number"&&(f[1]=d.byteLength-8,f[f.length-2]=d.byteLength-8,M(8)),d}function M(n){const t=x(n),e=N+t;let s=_-S;for(X();s<ft;){const i=f[s>>2],r=i&-2;if(i!==r||r<e){s+=r;continue}const c=r-e>=dt,h=c?e:r;if(f[s>>2]=h|1,f[s+h-A>>2]=h|1,c){const a=s+e,l=r-e;f[a>>2]=l,f[a+l-A>>2]=l}return $(),s+S}throw $(),new Error(`Out of memory (requesting ${n} bytes).`)}function mt(n){if(w(n%8===0,"Invalid pointer in free - pointer was not correctly aligned."),n===_||n===0)return;let t=n-S;X();let e=f[t>>2]&-2,s=t+e-A;if(f[t>>2]&=-2,f[s>>2]&=-2,s!==d.byteLength-A){const i=f[t+e>>2];i&1||(s+=i,e+=i)}if(t!==0){const i=f[t-A>>2];i&1||(t-=i,e+=i)}f[t>>2]=e,f[s>>2]=e,W.fill(0,t+S,s-S),$()}function Lt(n,t){if(w(n%8===0,"Invalid pointer in realloc - pointer was not correctly aligned."),n===_||n===0)return M(t);const e=x(t);X();const s=n-S,i=f[s>>2]&-2,r=i-N;if(r>=e)return $(),n;const u=s+i,c=f[u>>2];if(!(c&1)&&c-N>=e-i){const a=e-r,l=c-a>=dt,p=l?e+N:i+c;if(f[u>>2]=0,f[u-A>>2]=0,f[s>>2]=p|1,f[s+p-A>>2]=p|1,l){const m=i+c-p;f[s+p>>2]=m,f[s+p+m-A>>2]=m}return $(),n}$();const h=M(e);return K(n,r,h),mt(n),h}function K(n,t,e){W.copyWithin(e,n,n+t)}function pt(n,t,e){W.fill(e,n,n+t)}function Rt(n){if(n===_||n===0)return _;const t=(f[n-S>>2]&-2)-N,e=M(t);return K(n,t,e),e}function Ot(){d&&(pt(0,d.byteLength,0),f[1]=d.byteLength-8,f[f.length-2]=d.byteLength-8,M(8))}const o={init:Bt,get isInitialized(){return d!==void 0},alloc:M,free:mt,realloc:Lt,copy:K,copyPointer:Rt,set:pt,views:E,UNSAFE_CLEAR_ALL:Ot};class gt{#t;constructor(t){this.#t=t}get id(){return 0n}add(t){return this.#t.insertInto(this.id,t),this}addType(t){return this.#t.insertTypeInto(this.id,t),this}remove(t){return this.#t.removeFrom(this.id,t),this}despawn(){this.#t.despawn(this.id)}}class wt extends gt{#t;constructor(t,e){super(t),this.#t=e}get id(){return this.#t}}let F=0;function tt(n){w(o.isInitialized,"Tried to create a struct before memory was initialized."),!n.__$$b&&(n.__$$b=F!==0?F:o.alloc(n.constructor.size))}function k(n){const t=n.constructor,e=n.__$$b;for(const s of t.pointers??[])o.free(o.views.u32[e+s>>2]);o.free(e)}function et(n,t){F=t;const e=new n;return F=0,e}class v extends gt{static size=8;static alignment=8;constructor(t){super(t),tt(this)}get id(){return o.views.u64[this.__$$b>>3]}get index(){return o.views.u32[this.__$$b>>2]}get generation(){return o.views.u32[(this.__$$b>>2)+1]}}class Y{static createEmptyTable(t){const e=t.threads.queue(()=>{const i=o.alloc(8);return o.views.u32[i>>2]=4294967295,o.views.u32[(i>>2)+1]=4294967295,i});return new this(t,[],e,0n,0)}static createRecycledTable(t){const e=t.threads.queue(()=>{const s=t.config.getNewTableSize(0),i=o.alloc(8);return o.views.u32[i>>2]=0,o.views.u32[(i>>2)+1]=s,o.views.u32[(i>>2)+2]=o.alloc(s*v.size),i});return new this(t,[v],e,0n,1)}static create(t,e,s,i){const r=t.config.getNewTableSize(0),u=e.filter(a=>a.size>0),c=o.alloc(4*(2+u.length));o.views.u32[(c>>2)+1]=r;let h=2;for(const a of u)o.views.u32[(c>>2)+h]=o.alloc(a.size*r),h++;return new this(t,u,c,s,i)}#t;#e;#s;bitfield;#i;constructor(t,e,s,i,r){this.#t=t,this.#e=e,this.#s=s,this.bitfield=i,this.#i=r}get pointer(){return this.#s}get id(){return this.#i}get capacity(){return o.views.u32[(this.#s>>2)+1]}get size(){return o.views.u32[this.#s>>2]}set size(t){o.views.u32[this.#s>>2]=t}getColumn(t){return o.views.u32[(this.#s>>2)+2+this.#e.indexOf(t)]}hasColumn(t){return this.#e.includes(t)}delete(t){this.size--;let e=2;for(const s of this.#e){const i=o.views.u32[(this.#s>>2)+e];o.copy(i+this.size*s.size,s.size,i+t*s.size),e++}}move(t,e){e.capacity===e.size&&e.grow();const{u32:s,u64:i}=o.views;if(this.#e[0]!==v)return e.size++,BigInt(t);const r=this.getColumn(v),u=i[(r>>3)+this.size];for(const c of this.#e){const h=this.getColumn(c)+t*c.size;if(e.hasColumn(c))o.copy(h,c.size,e.getColumn(c)+e.size*c.size);else for(const a of c.pointers??[])o.free(s[h+a>>2])}return e.size++,this.delete(t),u}grow(){o.views.u32[(this.#s>>2)+1]=this.#t.config.getNewTableSize(this.capacity);let t=2;for(const e of this.#e)o.views.u32[(this.#s>>2)+t]=o.realloc(o.views.u32[(this.#s>>2)+t],e.size*this.capacity),t++}copyComponentIntoRow(t,e,s){this.hasColumn(e)&&o.copy(s,e.size,this.getColumn(e)+t*e.size)}}const qt=0x00000000ffffffffn,yt=n=>Number(n&qt),j=256,xt=1n<<32n;class Wt{static fromWorld(t){return new this(t,t.threads.queue(()=>{const{u32:e}=o.views,s=o.alloc(4*4)>>2;return e[s+2]=o.alloc(8*j),e[s+3]=j,s}))}#t;#e;#s;constructor(t,e){this.#e=e,this.#t=t,this.#s=t.archetypes[1]}spawn(){const{u32:t,u64:e}=o.views,s=this.#s.size,i=this.#s.getColumn(v);for(let r=this.#o();r<s;r=this.#o())if(this.#c(r))return e[(i>>3)+r]+xt;return BigInt(Atomics.add(t,this.#e,1))}isAlive(t){const{u32:e,u64:s}=o.views,i=this.getTableIndex(t),r=this.getRow(t),u=this.#t.archetypes[i].getColumn(v);return yt(t)<Atomics.load(e,this.#e)&&(i===0||i!==1||s[(u>>3)+r]===t)}resetCursor(){const{u32:t}=o.views;if(t[this.#e+1]=0,t[this.#e]>=this.#n){const e=Math.ceil((t[this.#e]+1)/j)*j;this.#i=o.realloc(this.#i,e*8),t[this.#e+3]=e}}getTableIndex(t){return o.views.u32[this.#r(t)]??0}setTableIndex(t,e){o.views.u32[this.#r(t)]=e}getRow(t){return o.views.u32[this.#r(t)+1]??0}setRow(t,e){o.views.u32[this.#r(t)+1]=e}getBitset(t){return this.#t.archetypes[this.getTableIndex(t)].bitfield}get#i(){return o.views.u32[this.#e+2]}set#i(t){o.views.u32[this.#e+2]=t}get#n(){return o.views.u32[this.#e+3]}set#n(t){o.views.u32[this.#e+3]=t}#r(t){return(this.#i>>2)+(yt(t)<<1)}#o(){return Atomics.load(o.views.u32,this.#e+1)}#c(t){return t===Atomics.compareExchange(o.views.u32,this.#e+1,t,t+1)}}const st=0,P=1,vt=2;class Nt{static fromWorld(t){const e=t.threads.queue(()=>{const i=t.components.reduce((c,h)=>c+h.size,0),r=[];let u=o.alloc(i);for(const c of t.components){if(r.push(u),c.size===0)continue;const h=new c;o.copy(h.__$$b,c.size,u),o.free(h.__$$b),u+=c.size}return r}),s=t.threads.queue(()=>o.alloc((1+3*t.config.threads)*4));return new this(t,e,s)}#t={type:0,dataStart:0,dataSize:0};#e;#s;#i;#n;#r;constructor(t,e,s){this.#e=t.entities,this.#s=t.components,this.#i=e,this.#n=s>>2,this.#r=3*Atomics.add(o.views.u32,this.#n,1)+this.#n+1}get#o(){return o.views.u32[this.#r]}set#o(t){o.views.u32[this.#r]=t}get#c(){return o.views.u32[this.#r+1]}set#c(t){o.views.u32[this.#r+1]=t}get#u(){return o.views.u32[this.#r+2]}set#u(t){o.views.u32[this.#r+2]=t}spawn(){const t=this.#e.spawn(),e=this.#h(P,t,v);return o.views.u64[e>>3]=t,new wt(this,t)}despawn(t){this.#h(st,t,v)}getEntityById(t){return new wt(this,t)}insertInto(t,e){const s=e.constructor;w(s!==v,"Tried to add Entity component, which is forbidden.");const i=this.#h(P,t,s);s.size!==0&&(o.copy(e.__$$b,s.size,i),this.#a(s,i))}insertTypeInto(t,e){w(e!==v,"Tried to add Entity component, which is forbidden.");const s=this.#h(P,t,e);e.size!==0&&(o.copy(this.#i[this.#s.indexOf(e)],e.size,s),this.#a(e,s))}removeFrom(t,e){w(e!==v,"Tried to remove Entity component, which is forbidden."),this.#h(st,t,e)}*[Symbol.iterator](){const{u32:t}=o.views,e=1+t[this.#n]*3;for(let s=1;s<e;s+=3){const i=t[this.#n+s+2],r=i+t[this.#n+s];for(let u=i;u<r;u+=t[u>>2])this.#t.type=t[u+4>>2],this.#t.dataSize=t[u>>2]-8,this.#t.dataStart=u+8,yield this.#t}}pushCommand(t,e){const s=8+x(t);let i=this.#o+s;this.#c<i&&(i<<=1,this.#u=o.realloc(this.#u,i),this.#c=i);const r=this.#u+this.#o;return o.views.u32[r>>2]=s,o.views.u32[r+4>>2]=e,this.#o+=s,r+8}reset(){const{u32:t}=o.views,e=1+t[this.#n]*3;for(let s=1;s<e;s+=3)t[this.#n+s]=0}#h(t,e,s){w(this.#s.includes(s),`Tried to add/remove unregistered component (${s.name}) on an Entity.`);const i=this.pushCommand(16+x(t*s.size),t);return o.views.u64[i>>3]=e,o.views.u16[i+8>>1]=this.#s.indexOf(s),i+16}#a(t,e){for(const s of t.pointers??[])o.views.u32[e+s>>2]=o.copyPointer(o.views.u32[e+s>>2])}}class Dt{isLocalToThread(){return!1}intersectsWith(t){return!1}intoArgument(t){return t.commands}onAddSystem(t){}}class Ut{#t=[];#e=[];#s;#i;#n;#r;#o;constructor(t,e,s,i,r){this.#s=t,this.#i=e,this.#r=s,this.#n=i,this.#o=r.commands}get length(){return this.#t.reduce((t,e)=>t+e.size,0)}*[Symbol.iterator](){let t;const e=this.#c();for(const s of this.#t)if(s.size!==0){for(let i=0;i<e.length;i++){const r=e[i]??t[i],u=s.hasColumn(r.constructor);!u&&e[i]!==null?(t??=[],t[i]=e[i],e[i]=null):u&&(e[i]===null&&(e[i]=t[i],t[i]=null),r.__$$b=s.getColumn(r.constructor))}for(let i=0;i<s.size;i++){yield this.#r?e[0]:e;for(const r of e)r&&(r.__$$b+=r.constructor.size)}}if(t)for(let s=0;s<t.length;s++)t[s]&&(e[s]=t[s]);this.#e.push(e)}forEach(t){if(this.#r)for(const e of this)t(e);else for(const e of this)t(...e)}#c(){return this.#e.pop()??this.#n.map(t=>{const e=t===v?new t(this.#o):new t;return k(e),e})}testAdd(t,e){this.#u(t)&&this.#t.push(e)}#u(t){for(let e=0;e<this.#s.length;e++)if((this.#s[e]&t)===this.#s[e]&&(this.#i[e]&t)===0n)return!0;return!1}}class Q{#t;constructor(t){this.#t=t}get value(){return this.#t}}class B{#t;constructor(t){this.#t=t}get value(){return this.#t}}class it{#t;constructor(t){this.#t=t}get value(){return this.#t}}class nt{#t;constructor(t){this.#t=t}get value(){return this.#t}}class rt{#t;#e;constructor(t,e){this.#t=t,this.#e=e}get l(){return this.#t}get r(){return this.#e}}const ot=(n,t,e=[])=>(Array.isArray(t)?t:[t]).reduce((s,i,r)=>e[r]?s:s|1n<<BigInt(n.indexOf(i)),0n);function L(n,t,e){let s=e;for(const i of Array.isArray(n)?n:[n])s=t(s,i);return s}function Ft(n,t){L(t,function e(s,i){i instanceof it||i instanceof nt?(i.value instanceof Array?i.value:[i.value]).forEach(u=>n.registerComponent(u)):i instanceof rt&&(L(i.l,e),L(i.r,e))})}function kt(n,t,e,s){const i=L(s,function u(c,h){if(h instanceof it){const a=ot(n,h.value);return{withs:c.withs.map(l=>l|a),withouts:c.withouts}}else if(h instanceof nt){const a=ot(n,h.value);return{withs:c.withs,withouts:c.withouts.map(l=>l|a)}}else if(h instanceof rt){const a=L(h.l,u,c),l=L(h.r,u,c);return{withs:[...a.withs,...l.withs],withouts:[...a.withouts,...l.withouts]}}throw new Error(`Unrecognized filter (${h.constructor.name}) in Query.`)},{withs:[ot(n,t,e)],withouts:[0n]}),r=i.withs.reduce((u,c,h)=>(i.withs[h]&i.withouts[h])===0n?u.add(h):u,new Set);return i.withs=i.withs.filter((u,c)=>r.has(c)),i.withouts=i.withouts.filter((u,c)=>r.has(c)),w(i.withs.length>0,"Tried to construct a query that cannot match any entities."),i}class ct{components=[];writes=[];optionals=[];filters;isIndividual;constructor(t,e=[]){this.isIndividual=!Array.isArray(t);const s=Array.isArray(t)?t:[t];for(const i of s){const r=i instanceof B||i instanceof Q&&i.value instanceof B;this.writes.push(r),this.optionals.push(i instanceof Q);const u=i instanceof B?i.value:i instanceof Q?i.value instanceof B?i.value.value:i.value:i;w(u.size>0,"You may not request direct access to ZSTs - use a With filter instead."),this.components.push(u)}this.filters=e}isLocalToThread(){return!1}intersectsWith(t){return t instanceof ct?this.components.some((e,s)=>t.components.some((i,r)=>e===i&&(this.writes[s]||t.writes[r]))):!1}onAddSystem(t){this.components.forEach(e=>t.registerComponent(e)),Ft(t,this.filters)}intoArgument(t){const{withs:e,withouts:s}=kt(t.components,this.components,this.optionals,this.filters),i=new Ut(e,s,this.isIndividual,this.components,t);return t.queries.push(i),i}}const Et={u8:Uint8Array,u16:Uint16Array,u32:Uint32Array,u64:BigUint64Array,i8:Int8Array,i16:Int16Array,i32:Int32Array,i64:BigInt64Array,f32:Float32Array,f64:Float64Array};let R=1,V=0;const z=[],O=[];let C={},ut={};const Yt=(n,t,e)=>{const s=O.reduce((r,u,c)=>u<t&&c<r?c:r,O.length);if(s===O.length){z.push(n),O.push(t),C[n]=z.length===0?0:V;return}const i=z[s];z.splice(s,0,n),O.splice(s,0,t),C[n]=C[i];for(let r=s+1;r<z.length;r++)C[z[r]]+=e};function D(n,t,e,s){return R=Math.max(R,t),s&&(ut[n]=s),Yt(n,t,e),V+=e,C}function jt(){const n=[];for(const e in ut)for(const s of ut[e])n.push(s+C[e]);const t={size:Math.ceil(V/R)*R,alignment:R,pointers:n};return V=0,R=1,C={},z.length=0,O.length=0,t}function T(n){return function(e,s){const i=Et[n],r=D(s,i.BYTES_PER_ELEMENT,i.BYTES_PER_ELEMENT),u=31-Math.clz32(i.BYTES_PER_ELEMENT);Object.defineProperty(e,s,{enumerable:!0,get(){return o.views[n][this.__$$b+r[s]>>u]},set(c){o.views[n][this.__$$b+r[s]>>u]=c}})}}const Qt=T("u8"),Vt=T("u16"),Zt=T("u32"),Ht=T("u64"),Gt=T("i8"),Jt=T("i16"),Xt=T("i32"),Kt=T("i64"),te=T("f32"),ee=T("f64"),se=function(t,e){const s=D(e,Uint8Array.BYTES_PER_ELEMENT,Uint8Array.BYTES_PER_ELEMENT);Object.defineProperty(t,e,{enumerable:!0,get(){return!!o.views.u8[this.__$$b+s[e]]},set(i){o.views.u8[this.__$$b+s[e]]=Number(i)}})};function ie(n){let t=n.length;for(let e=n.length-1;e>=0;e--){const s=n.charCodeAt(e);s>127&&s<=2047?t++:s>2047&&s<=65535&&(t+=2),s>=56320&&s<=57343&&e--}return t}const ne=new TextEncoder,re=new TextDecoder;function oe(n,t){const e=D(t,Uint32Array.BYTES_PER_ELEMENT,Uint32Array.BYTES_PER_ELEMENT*3,[8]);Object.defineProperty(n,t,{enumerable:!0,get(){const s=this.__$$b+e[t],i=o.views.u32[s>>2],r=o.views.u32[s+8>>2];return re.decode(o.views.u8.subarray(r,r+i))},set(s){const i=ie(s),r=this.__$$b+e[t],u=o.views.u32[r+4>>2];let c=o.views.u32[r+8>>2];if(u<i){const h=o.realloc(c,i);c=h,o.views.u32[r+4>>2]=i,o.views.u32[r+8>>2]=h}o.views.u32[r>>2]=i,ne.encodeInto(s,o.views.u8.subarray(c,c+i))}})}function ce({type:n,length:t}){return function(s,i){const r=Et[n],u=D(i,r.BYTES_PER_ELEMENT,r.BYTES_PER_ELEMENT*t),c=31-Math.clz32(r.BYTES_PER_ELEMENT);Object.defineProperty(s,i,{enumerable:!0,get(){return o.views[n].subarray(this.__$$b+u[i]>>c,(this.__$$b+u[i]>>c)+t)},set(h){o.views[n].set(h.subarray(0,t),this.__$$b+u[i]>>c)}})}}function ue(n){return function(e,s){const i=D(s,n.alignment,n.size,n.pointers);Object.defineProperty(e,s,{enumerable:!0,get(){return et(n,this.__$$b+i[s])},set(r){o.copy(r.__$$b,n.size,this.__$$b)}})}}function y(n){const{size:t,alignment:e,pointers:s}=jt();return class extends n{static size=t;static alignment=e;static pointers=s;constructor(...i){super(...i),tt(this)}}}y.bool=se,y.u8=Qt,y.u16=Vt,y.u32=Zt,y.u64=Ht,y.i8=Gt,y.i16=Jt,y.i32=Xt,y.i64=Kt,y.f32=te,y.f64=ee,y.string=oe,y.array=ce,y.substruct=ue;function Z(n){return typeof n=="function"&&typeof n.size=="number"&&typeof n.alignment=="number"}class ht{resource;canWrite;constructor(t){const e=t instanceof B;this.resource=e?t.value:t,this.canWrite=e}isLocalToThread(){return!Z(this.resource)}intersectsWith(t){return t instanceof ht?this.resource===t.resource&&(this.canWrite||t.canWrite):!1}onAddSystem(t){t.registerResource(this.resource)}intoArgument(t){return t.resources.find(e=>e.constructor===this.resource)}}class he{resourceType;constructor(t){this.resourceType=t}isLocalToThread(){return!Z(this.resourceType)}intersectsWith(t){return!1}onAddSystem(t){}async intoArgument({threads:t}){const{resourceType:e}=this,s=Z(e)?et(e,e.size!==0?t.queue(()=>o.alloc(e.size)):0):new e;return t.isMainThread&&await s.initialize?.(),s}}class bt{#t;#e;#s;#i;constructor(t,e,s,i){i===void 0&&(i=new e,k(i)),this.#t=t,this.#s=i,this.#e=e,this.#i=s>>2}get type(){return this.#e}get length(){return o.views.u32[this.#i]}*[Symbol.iterator](){const t=this.#e.size;this.#s.__$$b=o.views.u32[this.#i+2];for(let e=0;e<this.length;e++)yield this.#s,this.#s.__$$b+=t}clear(){const t=this.#t.pushCommand(4,vt);o.views.u32[t>>2]=this.#i<<2}}class ae extends bt{#t;#e;constructor(t,e,s){const i=new e;k(i),super(t,e,s,i),this.#t=i,this.#e=s>>2}create(){const t=this.#s();return this.#t.__$$b=t,o.copy(this.#e+3<<2,this.type.size,t),this.#t}createFrom(t){o.copy(t.__$$b,this.type.size,this.#s())}createDefault(){o.copy(this.#e+3<<2,this.type.size,this.#s())}clearImmediate(){o.views.u32[this.#e]=0}#s(){const{length:t}=this;return t===o.views.u32[this.#e+1]&&this.type.size!==0&&(o.views.u32[this.#e+2]=o.realloc(o.views.u32[this.#e+2],t*this.type.size+8*this.type.size),o.views.u32[this.#e+1]+=8),o.views.u32[this.#e]++,t*this.type.size+o.views.u32[this.#e+2]}}class Tt{eventType;constructor(t){this.eventType=t}isLocalToThread(){return!1}intersectsWith(t){return t instanceof H&&t.eventType===this.eventType}onAddSystem(t){t.registerEvent(this.eventType)}intoArgument(t){return t.eventReaders.find(e=>e.type===this.eventType)}}class H{eventType;constructor(t){this.eventType=t}isLocalToThread(){return!1}intersectsWith(t){return(t instanceof H||t instanceof Tt)&&t.eventType===this.eventType}onAddSystem(t){t.registerEvent(this.eventType)}intoArgument(t){return t.eventWriters.find(e=>e.type===this.eventType)}}class le{isLocalToThread(){return!0}intersectsWith(t){return!0}intoArgument(t){return t}onAddSystem(t){}}function b(n){return(...t)=>new n(...t)}const fe={Commands:b(Dt),Query:b(ct),Res:b(ht),World:b(le),SystemRes:b(he),Mut:b(B),Optional:b(Q),With:b(it),Without:b(nt),EventReader:b(Tt),EventWriter:b(H),Or(n,t){return new rt(n,t)}};class at{#t=0;#e=[];#s;fn;constructor(t,e){this.#s=t,this.fn=e}get parameters(){return this.#s(fe)}before(...t){for(const e of t)e.after(this);return this}after(...t){for(const e of t)this.#e.push(e);return this}beforeAll(){return this.#t=-1,this}afterAll(){return this.#t=1,this}clone(){return new at(this.#s,this.fn)}getAndClearDependencies(){const t={dependencies:this.#e,implicitPosition:this.#t};return this.#e=[],this.#t=0,t}}function At(n,t){return new at(n,t)}const lt=At(({World:n,SystemRes:t})=>[n(),t(Map)],function(t,e){const{commands:s,entities:i,archetypes:r,components:u}=t;i.resetCursor(),e.clear();for(const{type:c,dataStart:h}of s){if(c===vt){const m=o.views.u32[h>>2];o.views.u32[m>>2]=0}if(c!==P&&c!==st)continue;const a=o.views.u64[h>>3];let l=e.get(a);if(l===0n)continue;const p=o.views.u16[h+8>>1];l??=i.getBitset(a),e.set(a,c===P?l|1n<<BigInt(p):p===0?0n:l^1n<<BigInt(p))}for(const[c,h]of e)t.moveEntity(c,h);for(const{type:c,dataStart:h}of s){if(c!==P)continue;const a=o.views.u64[h>>3],l=i.getTableIndex(a);if(l===0||l===1)continue;const p=o.views.u32[h+8>>2];r[l].copyComponentIntoRow(i.getRow(a),u[p],h+16)}s.reset()});function*I(n){let t=0;for(;n!==0n;)(n&1n)===1n&&(yield t),n>>=1n,t++}let de=1;function _t(n,t){function e(...s){return[n,de++,s]}return e.channelName=n,e.onReceive=t,e}class U{static isMainThread=!!globalThis.document;isMainThread=U.isMainThread;static spawn(t,e){return new this(U.isMainThread?Array.from({length:t},()=>new Worker(e,{type:"module"})):[globalThis])}#t=new Map;#e=new Map;#s={};#i=[];#n;constructor(t){this.#n=t;const e=({currentTarget:s,data:[i,r,u]})=>{if(this.#t.has(r)){const c=this.#e.get(r);c.push(u),c.length===this.#n.length&&(this.#t.get(r)(c),this.#t.delete(r),this.#e.delete(r))}else i in this.#s?s.postMessage([i,r,this.#s[i](...u)]):s.postMessage([i,r,null])};for(const s of this.#n)s.addEventListener("message",e)}setListener(t,e){this.#s[t]=e}deleteListener(t){delete this.#s[t]}send(t){return this.#n.length===0?Promise.resolve([]):new Promise(e=>{for(const s of this.#n)s.postMessage(t);this.#e.set(t[1],[]),this.#t.set(t[1],e)})}queue(t){if(U.isMainThread){const e=t();return this.#i.push(e),e}return this.#i.shift()}async wrapInQueue(t){const e="threadGroup::queue";let s;return this.isMainThread?(s=await t(),await this.send([e,0,[this.#i]])):(s=await new Promise(i=>this.setListener(e,r=>{this.#i=r,i(t())})),this.deleteListener(e)),this.#i.length=0,s}}const St=_t("thyseus::sendTable",n=>(t,e,s)=>{const i=[...I(s)].reduce((u,c)=>{const h=n.components[c];return h.size>0&&u.push(h),u},[]),r=new Y(n,i,t,s,e);n.archetypes[e]=r;for(const u of n.queries)u.testAdd(s,r)});function me(n){n.registerComponent(v).addSystem(lt.afterAll()).registerThreadChannel(St)}function pe(n,t){return n.parameters.some(e=>t.parameters.some(s=>e.intersectsWith(s)||s.intersectsWith(e)))?1:0}function zt(n){return n.map(t=>n.reduce((e,s,i)=>e|BigInt(pe(t,s))<<BigInt(i),0n))}function Ct(n,t,e){const s=t.map(r=>r.dependencies.reduce((u,c)=>{const h=n.indexOf(c);return h===-1?u:u|1n<<BigInt(h)},0n)),i=[...s];i.forEach(function r(u,c){for(const h of I(u))r(i[h],h),i[c]|=i[h]});for(let r=0;r<i.length;r++)w((i[r]&1n<<BigInt(r))===0n,`Circular Dependency Detected - Sytem #${r} (${n[r].fn.name}) depends on itself!`);for(let r=0;r<n.length;r++){const u=t[r];if(u.implicitPosition===-1)for(const c of I(e[r]))c!==r&&(i[r]&1n<<BigInt(c))===0n&&(s[c]|=1n<<BigInt(r),i[c]|=1n<<BigInt(r));else if(u.implicitPosition===1)for(const c of I(e[r]))c!==r&&(i[c]&1n<<BigInt(r))===0n&&(s[r]|=1n<<BigInt(c),i[r]|=1n<<BigInt(c))}return s.forEach((r,u)=>s[u]&=e[u]),s}function It(n,t,e){for(const s of I(t))if(n[s]===e)return!1;return!0}let ge=0;const G=(...n)=>{};class we{static fromWorld(t,e,s){const i=t.threads.queue(()=>zt(e)),r=t.threads.queue(()=>Ct(e,s,i)),u=t.threads.isMainThread?e.map(()=>!0):e.map(l=>!l.parameters.some(p=>p.isLocalToThread())),{buffer:c}=o.views,h=t.threads.queue(()=>o.alloc(8+e.length*3)),a=t.threads.queue(()=>`thyseus::ParallelExecutor${ge++}`);return new this(t,new Uint32Array(c,h,2),new Uint8Array(c,h+8,e.length),new Uint8Array(c,h+8+e.length,e.length),new Uint8Array(c,h+8+e.length*2,e.length),i,r,u,a)}#t=G;#e=G;#s;#i;#n;#r;#o;#c;#u;#h;#a;#d;#l;#m;constructor(t,e,s,i,r,u,c,h,a){this.#l=t.systems,this.#m=t.arguments,this.#d=t.threads.isMainThread,this.#c=u,this.#u=c,this.#o=h,this.#s=e,this.#i=s,this.#n=i,this.#r=r,this.#a=new BroadcastChannel(a),this.#h=a,this.#a.addEventListener("message",({data:l})=>{l===0?this.#p():l===1?(this.#t(),this.#t=G):(this.#e(),this.#e=G)})}async start(){return this.#f=this.#l.length,this.#s[1]=0,this.#i.fill(1),this.#r.fill(0),this.#n.fill(0),this.#g(),this.#p()}get#f(){return this.#s[0]}set#f(t){this.#s[0]=t}async#p(){for(;this.#f>0;){let t=-1;if(await navigator.locks.request(this.#h,()=>{t=this.#i.findIndex((e,s)=>!!e&&It(this.#r,this.#u[s],0)&&It(this.#n,this.#c[s],1)&&this.#o[s]),t!==-1&&(this.#i[t]=0,this.#n[t]=1,this.#f--)}),t===-1){await this.#y();continue}await this.#l[t](...this.#m[t]),await navigator.locks.request(this.#h,()=>{this.#n[t]=0,this.#r[t]=1,Atomics.add(this.#s,1,1)}),this.#w()}this.#d&&Atomics.load(this.#s,1)!==this.#l.length&&await this.#v()}#g(){this.#a.postMessage(0)}#w(){Atomics.load(this.#s,1)===this.#l.length?this.#a.postMessage(2):this.#a.postMessage(1)}async#y(){return new Promise(t=>this.#t=t)}async#v(){return new Promise(t=>this.#e=t)}}class ye{static fromWorld(t,e,s){const i=Ct(e,s,zt(e)),r=i.reduce(function u(c,h,a){for(const l of I(h))u(c,i[l],l);return c.includes(a)||c.push(a),c},[]);return new this(t,r)}#t;#e;#s;constructor(t,e){this.#t=t.systems,this.#e=t.arguments,this.#s=e}async start(){for(const t of this.#s)await this.#t[t](...this.#e[t])}}class ve{systems=[];#t=[];#e=[];components=new Set;resources=new Set;events=new Set;threadChannels=[];executor;config;url;constructor(t,e){this.config=t,this.url=e,this.executor=t.threads>1?we:ye,me(this)}addSystem(t){return this.systems.push(t),this.#t.push(t.getAndClearDependencies()),t.parameters.forEach(e=>e.onAddSystem(this)),this}addStartupSystem(t){return this.#e.push(t),t.parameters.forEach(e=>e.onAddSystem(this)),this}addPlugin(t){return t(this),this}registerComponent(t){return this.components.add(t),this}registerResource(t){return this.resources.add(t),this}registerEvent(t){return this.events.add(t),this}registerThreadChannel(t){return this.threadChannels.push(t),this}setExecutor(t){return this.executor=t,this}async build(){const t=U.spawn(this.config.threads-1,this.url),e=await t.wrapInQueue(()=>new $t(this.config,t,this.executor,[...this.components],[...this.resources],[...this.events],this.systems,this.#t,this.threadChannels));for(const s of this.systems)e.systems.push(s.fn),e.arguments.push(await Promise.all(s.parameters.map(i=>i.intoArgument(e))));if(t.isMainThread){await Promise.all(e.resources.map(s=>s.initialize?.(e)));for(const s of this.#e)await s.fn(...s.parameters.map(i=>i.intoArgument(e)));await lt.fn(e,new Map)}return e}}const Ee=1048576,be=(n={})=>({threads:1,memory:64*Ee,getNewTableSize:t=>t===0?8:t*2,...n}),Te=({threads:n,memory:t},e)=>{n>1&&(w(isSecureContext,"Invalid config - Multithreading (threads > 1) requires a secure context."),w(typeof SharedArrayBuffer<"u","Invalid config - Multithreading (threads > 1) requires SharedArrayBuffer."),w(e,"Invalid config - Multithreading (threads > 1) requires a module URL parameter.",TypeError)),w(Number.isInteger(n)&&0<n&&n<64,"Invalid config - 'threads' must be an integer such that 0 < threads < 64",RangeError),w(Number.isInteger(t)&&t<2**32,"Invalid config - 'memory' must be at most 4 GB ((2**32) - 1 bytes)")};function Ae(n,t){const e=be(n);return Te(e,t),e}class $t{static new(t,e){return new ve(Ae(t,e),e)}archetypes=[];#t=new Map;queries=[];resources=[];eventReaders=[];eventWriters=[];systems=[];arguments=[];commands;entities;config;threads;executor;components;constructor(t,e,s,i,r,u,c,h,a){this.config=t,this.threads=e,o.init(this.threads.queue(()=>o.init(t.memory,t.threads>1)));const l=Y.createEmptyTable(this),p=Y.createRecycledTable(this);this.archetypes.push(l,p),this.#t.set(0n,p);for(const m of a)this.threads.setListener(m.channelName,m.onReceive(this));this.components=i,this.entities=Wt.fromWorld(this),this.commands=Nt.fromWorld(this),this.executor=s.fromWorld(this,c,h);for(const m of u){const J=this.threads.queue(()=>{const Mt=o.alloc(12+m.size);if(m.size!==0){const Pt=new m;o.copy(Pt.__$$b,m.size,Mt+12),o.free(Pt.__$$b)}return Mt});this.eventReaders.push(new bt(this.commands,m,J)),this.eventWriters.push(new ae(this.commands,m,J))}for(const m of r)if(Z(m)){const J=this.threads.queue(()=>m.size!==0?o.alloc(m.size):0);this.resources.push(et(m,J))}else e.isMainThread&&this.resources.push(new m)}async update(){return this.executor.start()}moveEntity(t,e){if(!this.entities.isAlive(t))return;const s=this.archetypes[this.entities.getTableIndex(t)],i=this.#e(e),r=this.entities.getRow(t),u=s.move(r,i);this.entities.setRow(u,r),this.entities.setTableIndex(t,i.id),this.entities.setRow(t,i.size-1)}#e(t){let e=this.#t.get(t);if(e)return e;const s=this.archetypes.length;e=Y.create(this,Array.from(I(t),i=>this.components[i]),t,s),this.#t.set(t,e),this.archetypes.push(e),this.threads.send(St(e.pointer,s,t));for(const i of this.queries)i.testAdd(t,e);return e}}function _e(n){return n}g.Entity=v,g.World=$t,g.applyCommands=lt,g.createThreadChannel=_t,g.definePlugin=_e,g.defineSystem=At,g.dropStruct=k,g.initStruct=tt,g.struct=y,Object.defineProperty(g,Symbol.toStringTag,{value:"Module"})});
